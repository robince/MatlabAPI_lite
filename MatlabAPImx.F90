!PyF95.start
!...............................................................................
!.
!. This code was pre-parsed by PyF95++, a block parser and code generator.
!. Website: http://blockit.sourceforge.net/
!. Wiki: http://blockit.sourceforge.net/wiki.html
!. Download: http://blockit.sourceforge.net/download.html
!.
!................................................................................
!PyF95.hash: 64aed17ef68ae94b7f6c68050bac8e0682cc91fe164738b0c9b28929cc899aa1
!PyF95.symbol: MatlabAPImx
!PyF95.symbol: fpGetPr|MatlabAPImx
!PyF95.symbol: uppercase|MatlabAPImx
!PyF95.symbol: fpGetCells|MatlabAPImx
!PyF95.symbol: fpGetDimensions|MatlabAPImx
!PyF95.symbol: template_4316072464|MatlabAPImx
!PyF95.symbol: template_4303246544|MatlabAPImx
!PyF95.symbol: template_4316072464_5|MatlabAPImx
!PyF95.symbol: template_4316072464_2|MatlabAPImx
!PyF95.symbol: template_4316072464_3|MatlabAPImx
!PyF95.symbol: template_4316072464_6|MatlabAPImx
!PyF95.symbol: template_4316072464_7|MatlabAPImx
!PyF95.symbol: template_4316072464_4|MatlabAPImx
!PyF95.symbol: template_4316072464_1|MatlabAPImx
!PyF95.symbol: fpGetPi_|template_4303246544|MatlabAPImx
!PyF95.symbol: fpGetPr_|template_4303246544|MatlabAPImx
!PyF95.symbol: fpGetCells_|template_4316072464|MatlabAPImx
!PyF95.symbol: fpAllocate_|template_4303246544|MatlabAPImx
!PyF95.symbol: fpDeallocate_|template_4303246544|MatlabAPImx
!PyF95.symbol: mxArrayHeader_|template_4303246544|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetCells__3|template_4316072464_3|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetCells__1|template_4316072464_1|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetCells__2|template_4316072464_2|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetCells__7|template_4316072464_7|MatlabAPImx
!PyF95.symbol: fpGetCells__4|template_4316072464_4|MatlabAPImx
!PyF95.symbol: fpGetCells__6|template_4316072464_6|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetCells__5|template_4316072464_5|MatlabAPImx
!PyF95.symbol: template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322528016|fpGetPi_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4316102928|fpGetPr_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4303305360|fpGetPr_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322503184|fpGetPi_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322566544|fpAllocate_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322546320|fpAllocate_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322626704|fpGetCells_|template_4316072464|MatlabAPImx
!PyF95.symbol: special_4322569872|fpDeallocate_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322594384|mxArrayHeader_|template_4303246544|MatlabAPImx
!PyF95.symbol: special_4322594128|mxArrayHeader_|template_4303246544|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322626704_6_4316560208|fpGetCells__6|template_4316072464_6|MatlabAPImx
!PyF95.symbol: special_4322626704_7_4316530384|fpGetCells__7|template_4316072464_7|MatlabAPImx
!PyF95.symbol: special_4322626704_3_4316581072|fpGetCells__3|template_4316072464_3|MatlabAPImx
!PyF95.symbol: special_4322626704_1_4316508624|fpGetCells__1|template_4316072464_1|MatlabAPImx
!PyF95.symbol: special_4322626704_5_4316649744|fpGetCells__5|template_4316072464_5|MatlabAPImx
!PyF95.symbol: special_4322626704_4_4303183952|fpGetCells__4|template_4316072464_4|MatlabAPImx
!PyF95.symbol: special_4322626704_2_4316624016|fpGetCells__2|template_4316072464_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_4_4335738256|fpGetPr__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_3_4325072272|fpGetPi__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_6_4322582736|fpGetPi__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_2_4325375184|fpGetPr__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_3_4325115344|fpGetPi__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_5_4335619472|fpGetPi__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_3_4324970064|fpGetPr__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_5_4335593552|fpGetPi__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_5_4335593680|fpGetPr__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_6_4322541136|fpGetPi__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_0_4324769552|fpGetPi__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_4_4335738384|fpGetPi__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_0_4324769744|fpGetPr__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_1_4322908176|fpGetPr__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_3_4325089360|fpGetPr__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_2_4334830160|fpGetPr__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_4_4335756048|fpGetPr__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_0_4324674832|fpGetPr__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_1_4323010256|fpGetPi__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_6_4322439120|fpGetPr__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322503184_real_c_double_2_4325375312|fpGetPi__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_1_4323010384|fpGetPr__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_2_4334851600|fpGetPi__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4316102928_real_c_double_5_4335491536|fpGetPr__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_1_4324342800|fpGetPi__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4303305360_real_c_double_6_4322541264|fpGetPr__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_0_4324803728|fpGetPi__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322528016_real_c_double_4_4335781584|fpGetPi__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_0_4324827024|fpAllocate__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_6_4322610896|fpAllocate__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_4_4335781456|fpAllocate__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_0_4324803600|fpAllocate__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_2_4334851472|fpAllocate__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_3_4325137296|fpAllocate__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_6_4322560976|fpAllocate__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_1_4324342736|fpAllocate__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_5_4335659216|fpAllocate__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_5_4335639184|fpAllocate__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_2_4334881744|fpAllocate__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_4_4335803536|fpAllocate__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322546320_real_c_double_3_4325115216|fpAllocate__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322566544_real_c_double_1_4324382544|fpAllocate__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_6_4322634640|fpDeallocate__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_0_4324846672|fpDeallocate__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_2_4334894544|fpDeallocate__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_5_4335682960|fpDeallocate__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_4_4335824528|fpDeallocate__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_1_4324406288|fpDeallocate__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322569872_real_c_double_3_4325158032|fpDeallocate__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_6_4322488080|mxArrayHeader__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_0_4324879696|mxArrayHeader__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_0_4324737296|mxArrayHeader__real_c_double_0|template_4303246544_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_1_4324346448|mxArrayHeader__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_4_4335711760|mxArrayHeader__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_5_4335713232|mxArrayHeader__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_4_4335848272|mxArrayHeader__real_c_double_4|template_4303246544_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_3_4325191312|mxArrayHeader__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_6_4322655376|mxArrayHeader__real_c_double_6|template_4303246544_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_5_4335545488|mxArrayHeader__real_c_double_5|template_4303246544_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_1_4322962192|mxArrayHeader__real_c_double_1|template_4303246544_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_3_4325041360|mxArrayHeader__real_c_double_3|template_4303246544_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4322594384_real_c_double_2_4334923600|mxArrayHeader__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322594128_real_c_double_2_4325352720|mxArrayHeader__real_c_double_2|template_4303246544_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_0_4322864080|fpGetPi__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_4_4335426704|fpGetPr__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_1_4322399760|fpGetPr__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_3_4324623376|fpGetPi__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_1_4322421456|fpGetPi__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_6_4336045456|fpGetPr__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_4_4335469712|fpGetPi__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_2_4324825552|fpGetPr__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_0_4322840144|fpGetPr__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_6_4336088592|fpGetPi__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_5_4335170896|fpGetPi__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_4_4335336976|fpGetPr__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_2_4324927504|fpGetPr__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_2_4324949200|fpGetPi__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_1_4322399056|fpGetPi__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_4_4335426832|fpGetPi__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_0_4322749712|fpGetPr__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_5_4335123792|fpGetPi__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_5_4335123664|fpGetPr__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_2_4324926800|fpGetPi__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_3_4324624080|fpGetPr__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_3_4324522128|fpGetPr__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int8_t_6_4336045584|fpGetPi__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_3_4324641680|fpGetPi__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int8_t_0_4322881680|fpGetPi__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_6_4336066960|fpGetPr__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int8_t_5_4335149456|fpGetPr__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int8_t_1_4322249040|fpGetPr__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_5_4335170384|fpAllocate__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_4_4335493008|fpAllocate__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_0_4324458256|fpGetPr__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_6_4336088080|fpAllocate__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_4_4335469200|fpAllocate__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_2_4324992976|fpAllocate__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_1_4322420752|fpAllocate__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_1_4322724624|fpGetPi__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_3_4324689552|fpAllocate__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_0_4324358416|fpGetPr__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_2_4316422608|fpGetPi__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_1_4322438480|fpAllocate__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_5_4334881616|fpGetPr__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_6_4336118672|fpAllocate__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_0_4324457552|fpGetPi__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_6_4325252368|fpGetPi__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_5_4334996816|fpGetPi__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_4_4335282256|fpGetPr__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_3_4335922704|fpGetPi__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_2_4316678800|fpGetPr__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_1_4322609424|fpGetPr__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_4_4335281552|fpGetPi__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_2_4324948496|fpAllocate__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_1_4322702352|fpGetPi__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_0_4324503888|fpGetPi__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_3_4335803408|fpGetPr__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_6_4325137168|fpGetPr__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_0_4322864976|fpAllocate__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_6_4325230800|fpGetPr__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_5_4334971152|fpGetPr__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_2_4316446288|fpGetPr__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4316102928_integer_c_int16_t_4_4335192720|fpGetPr__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_2_4316700496|fpGetPi__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_1_4322703056|fpGetPr__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int8_t_3_4324640976|fpAllocate__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_6_4325230096|fpGetPi__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_0_4322909712|fpAllocate__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int8_t_5_4335192784|fpAllocate__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322528016_integer_c_int16_t_4_4335307920|fpGetPi__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4303305360_integer_c_int16_t_3_4335901136|fpGetPr__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_5_4334970448|fpGetPi__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322503184_integer_c_int16_t_3_4335900432|fpGetPi__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_5_4335217936|fpDeallocate__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_6_4336131536|fpDeallocate__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_1_4322484880|fpDeallocate__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_2_4325024912|fpDeallocate__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_3_4324717392|fpDeallocate__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_0_4322945744|fpDeallocate__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int8_t_4_4335520848|fpDeallocate__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_5_4335048784|fpAllocate__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_4_4335307216|fpAllocate__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_2_4325042896|mxArrayHeader__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_2_4322250512|fpAllocate__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_1_4322294480|mxArrayHeader__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_0_4324523600|fpAllocate__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_0_4324478096|fpAllocate__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_0_4322799440|mxArrayHeader__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_1_4322749840|fpAllocate__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_5_4335021776|fpAllocate__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_4_4335408272|mxArrayHeader__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_2_4324879568|mxArrayHeader__integer_c_int8_t_2|template_4303246544_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_5_4335242704|mxArrayHeader__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_2_4316720720|fpAllocate__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_1_4322723920|fpAllocate__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_4_4335545616|mxArrayHeader__integer_c_int8_t_4|template_4303246544_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_1_4322506960|mxArrayHeader__integer_c_int8_t_1|template_4303246544_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_0_4322962320|mxArrayHeader__integer_c_int8_t_0|template_4303246544_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_4_4335355792|fpAllocate__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_5_4335088976|mxArrayHeader__integer_c_int8_t_5|template_4303246544_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_3_4324739472|mxArrayHeader__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_6_4325281424|fpAllocate__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_6_4325300240|fpAllocate__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322546320_integer_c_int16_t_3_4335922000|fpAllocate__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_3_4324580176|mxArrayHeader__integer_c_int8_t_3|template_4303246544_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int8_t_6_4336160400|mxArrayHeader__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322566544_integer_c_int16_t_3_4335962384|fpAllocate__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int8_t_6_4336023056|mxArrayHeader__integer_c_int8_t_6|template_4303246544_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_5_4335072528|fpDeallocate__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_2_4316460688|fpDeallocate__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_0_4324551440|fpDeallocate__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_6_4325328080|fpDeallocate__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_3_4335994320|fpDeallocate__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_4_4335379536|fpDeallocate__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322569872_integer_c_int16_t_1_4322796240|fpDeallocate__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_2_4316476816|mxArrayHeader__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_1_4322655248|mxArrayHeader__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_4_4335409808|mxArrayHeader__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_0_4324344976|mxArrayHeader__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_5_4334923344|mxArrayHeader__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_2_4316488592|mxArrayHeader__integer_c_int16_t_2|template_4303246544_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_3_4335849232|mxArrayHeader__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_1_4322822416|mxArrayHeader__integer_c_int16_t_1|template_4303246544_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_3_4336024592|mxArrayHeader__integer_c_int16_t_3|template_4303246544_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_6_4325191184|mxArrayHeader__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_5_4335090512|mxArrayHeader__integer_c_int16_t_5|template_4303246544_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_0_4324580304|mxArrayHeader__integer_c_int16_t_0|template_4303246544_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4322594128_integer_c_int16_t_4_4335242576|mxArrayHeader__integer_c_int16_t_4|template_4303246544_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4322594384_integer_c_int16_t_6_4325354256|mxArrayHeader__integer_c_int16_t_6|template_4303246544_integer_c_int16_t_6|MatlabAPImx
!PyF95.end
!*************************************************************************************
! 
!  MATLAB (R) is a trademark of The Mathworks (R) Corporation
! 
!  Copyright:   (c) 2009, 2011 by James Tursa
!  Copyright:   (c) 2012 by Robin Ince
!  All Rights Reserved
! 
!   This code uses the BSD License:
! 
!   Redistribution and use in source and binary forms, with or without 
!   modification, are permitted provided that the following conditions are 
!   met:
! 
!      * Redistributions of source code must retain the above copyright 
!        notice, this list of conditions and the following disclaimer.
!      * Redistributions in binary form must reproduce the above copyright 
!        notice, this list of conditions and the following disclaimer in 
!        the documentation and/or other materials provided with the distribution
!       
!   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
!   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
!   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
!   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
!   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
!   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
!   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
!   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
!   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
!   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
!   POSSIBILITY OF SUCH DAMAGE.
#include "fintrf.h"
#include "repidx.h"

module MatlabAPImx
  use iso_c_binding
  implicit none

#include 'mxInterface.inc'

  ! instantiate templates from fpGetPr
  interface fpGetPr
    module procedure fpGetPr__real_c_double_0
    module procedure fpGetPr__real_c_double_1
    module procedure fpGetPr__real_c_double_2
    module procedure fpGetPr__real_c_double_3
    module procedure fpGetPr__real_c_double_4
    module procedure fpGetPr__real_c_double_5
    module procedure fpGetPr__real_c_double_6
    !module procedure fpGetPr__real_c_double_7
    module procedure fpGetPr__integer_c_int16_t_0
    module procedure fpGetPr__integer_c_int16_t_1
    module procedure fpGetPr__integer_c_int16_t_2
    module procedure fpGetPr__integer_c_int16_t_3
    module procedure fpGetPr__integer_c_int16_t_4
    module procedure fpGetPr__integer_c_int16_t_5
    module procedure fpGetPr__integer_c_int16_t_6
    !module procedure fpGetPr__integer_c_int16_t_7
    module procedure fpGetPr__integer_c_int8_t_0
    module procedure fpGetPr__integer_c_int8_t_1
    module procedure fpGetPr__integer_c_int8_t_2
    module procedure fpGetPr__integer_c_int8_t_3
    module procedure fpGetPr__integer_c_int8_t_4
    module procedure fpGetPr__integer_c_int8_t_5
    module procedure fpGetPr__integer_c_int8_t_6
    !module procedure fpGetPr__integer_c_int8_t_7
  end interface

  ! rank-only templates
  interface fpGetCells
    module procedure fpGetCells__1
    module procedure fpGetCells__2
    module procedure fpGetCells__3
    module procedure fpGetCells__4
    module procedure fpGetCells__5
    module procedure fpGetCells__6
    module procedure fpGetCells__7
  end interface

  ! AutoInterface will provide all other procedures
  !..............................................................................
  ! `AutoInterface` Generated Code Section
  !..............................................................................
  interface mxArrayHeader
    module procedure mxArrayHeader__integer_c_int8_t_6
    module procedure mxArrayHeader__integer_c_int8_t_5
    module procedure mxArrayHeader__integer_c_int8_t_4
    module procedure mxArrayHeader__integer_c_int8_t_3
    module procedure mxArrayHeader__integer_c_int8_t_2
    module procedure mxArrayHeader__integer_c_int8_t_1
    module procedure mxArrayHeader__integer_c_int8_t_0
    module procedure mxArrayHeader__real_c_double_1
    module procedure mxArrayHeader__real_c_double_0
    module procedure mxArrayHeader__real_c_double_3
    module procedure mxArrayHeader__real_c_double_2
    module procedure mxArrayHeader__real_c_double_5
    module procedure mxArrayHeader__real_c_double_4
    module procedure mxArrayHeader__real_c_double_6
    module procedure mxArrayHeader__integer_c_int16_t_1
    module procedure mxArrayHeader__integer_c_int16_t_0
    module procedure mxArrayHeader__integer_c_int16_t_3
    module procedure mxArrayHeader__integer_c_int16_t_2
    module procedure mxArrayHeader__integer_c_int16_t_5
    module procedure mxArrayHeader__integer_c_int16_t_4
    module procedure mxArrayHeader__integer_c_int16_t_6
  end interface

  interface fpGetPi
    module procedure fpGetPi__integer_c_int8_t_6
    module procedure fpGetPi__integer_c_int8_t_5
    module procedure fpGetPi__integer_c_int8_t_4
    module procedure fpGetPi__integer_c_int8_t_3
    module procedure fpGetPi__integer_c_int8_t_2
    module procedure fpGetPi__integer_c_int8_t_1
    module procedure fpGetPi__integer_c_int8_t_0
    module procedure fpGetPi__real_c_double_1
    module procedure fpGetPi__real_c_double_0
    module procedure fpGetPi__real_c_double_3
    module procedure fpGetPi__real_c_double_2
    module procedure fpGetPi__real_c_double_5
    module procedure fpGetPi__real_c_double_4
    module procedure fpGetPi__real_c_double_6
    module procedure fpGetPi__integer_c_int16_t_1
    module procedure fpGetPi__integer_c_int16_t_0
    module procedure fpGetPi__integer_c_int16_t_3
    module procedure fpGetPi__integer_c_int16_t_2
    module procedure fpGetPi__integer_c_int16_t_5
    module procedure fpGetPi__integer_c_int16_t_4
    module procedure fpGetPi__integer_c_int16_t_6
  end interface

  interface fpAllocate
    module procedure fpAllocate__integer_c_int8_t_6
    module procedure fpAllocate__integer_c_int8_t_5
    module procedure fpAllocate__integer_c_int8_t_4
    module procedure fpAllocate__integer_c_int8_t_3
    module procedure fpAllocate__integer_c_int8_t_2
    module procedure fpAllocate__integer_c_int8_t_1
    module procedure fpAllocate__integer_c_int8_t_0
    module procedure fpAllocate__real_c_double_1
    module procedure fpAllocate__real_c_double_0
    module procedure fpAllocate__real_c_double_3
    module procedure fpAllocate__real_c_double_2
    module procedure fpAllocate__real_c_double_5
    module procedure fpAllocate__real_c_double_4
    module procedure fpAllocate__real_c_double_6
    module procedure fpAllocate__integer_c_int16_t_1
    module procedure fpAllocate__integer_c_int16_t_0
    module procedure fpAllocate__integer_c_int16_t_3
    module procedure fpAllocate__integer_c_int16_t_2
    module procedure fpAllocate__integer_c_int16_t_5
    module procedure fpAllocate__integer_c_int16_t_4
    module procedure fpAllocate__integer_c_int16_t_6
  end interface

  interface fpDeallocate
    module procedure fpDeallocate__integer_c_int8_t_6
    module procedure fpDeallocate__integer_c_int8_t_5
    module procedure fpDeallocate__integer_c_int8_t_4
    module procedure fpDeallocate__integer_c_int8_t_3
    module procedure fpDeallocate__integer_c_int8_t_2
    module procedure fpDeallocate__integer_c_int8_t_1
    module procedure fpDeallocate__integer_c_int8_t_0
    module procedure fpDeallocate__real_c_double_1
    module procedure fpDeallocate__real_c_double_0
    module procedure fpDeallocate__real_c_double_3
    module procedure fpDeallocate__real_c_double_2
    module procedure fpDeallocate__real_c_double_5
    module procedure fpDeallocate__real_c_double_4
    module procedure fpDeallocate__real_c_double_6
    module procedure fpDeallocate__integer_c_int16_t_1
    module procedure fpDeallocate__integer_c_int16_t_0
    module procedure fpDeallocate__integer_c_int16_t_3
    module procedure fpDeallocate__integer_c_int16_t_2
    module procedure fpDeallocate__integer_c_int16_t_5
    module procedure fpDeallocate__integer_c_int16_t_4
    module procedure fpDeallocate__integer_c_int16_t_6
  end interface

  !..............................................................................

  contains

  subroutine fpGetPr__integer_c_int8_t_6(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_6

  subroutine fpGetPi__integer_c_int8_t_6(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_6

  subroutine fpAllocate__integer_c_int8_t_6(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_6

  subroutine fpDeallocate__integer_c_int8_t_6(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,6)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,6) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_6

  function mxArrayHeader__integer_c_int8_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,6)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,6)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,6) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,6) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_6

  subroutine fpGetPr__integer_c_int16_t_3(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_3

  subroutine fpGetPi__integer_c_int16_t_3(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_3

  subroutine fpAllocate__integer_c_int16_t_3(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_3

  subroutine fpDeallocate__integer_c_int16_t_3(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,3)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,3) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_3

  function mxArrayHeader__integer_c_int16_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,3)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,3)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,3) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,3) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_3

  subroutine fpGetPr__real_c_double_4(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_4

  subroutine fpGetPi__real_c_double_4(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_4

  subroutine fpAllocate__real_c_double_4(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,4)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_4

  subroutine fpDeallocate__real_c_double_4(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,4)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,4) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_4

  function mxArrayHeader__real_c_double_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,4)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,4)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,4) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,4) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_4

  subroutine fpGetPr__real_c_double_5(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_5

  subroutine fpGetPi__real_c_double_5(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_5

  subroutine fpAllocate__real_c_double_5(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,5)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_5

  subroutine fpDeallocate__real_c_double_5(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,5)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,5) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_5

  function mxArrayHeader__real_c_double_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,5)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,5)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,5) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,5) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_5

  subroutine fpGetPr__integer_c_int8_t_4(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_4

  subroutine fpGetPi__integer_c_int8_t_4(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_4

  subroutine fpAllocate__integer_c_int8_t_4(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_4

  subroutine fpDeallocate__integer_c_int8_t_4(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,4)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,4) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_4

  function mxArrayHeader__integer_c_int8_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,4)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,4)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,4) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,4) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_4

  subroutine fpGetPr__integer_c_int16_t_4(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_4

  subroutine fpGetPi__integer_c_int16_t_4(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_4

  subroutine fpAllocate__integer_c_int16_t_4(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,4)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_4

  subroutine fpDeallocate__integer_c_int16_t_4(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,4)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,4) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_4

  function mxArrayHeader__integer_c_int16_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,4)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,4)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,4) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,4) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_4

  subroutine fpGetPr__integer_c_int8_t_5(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_5

  subroutine fpGetPi__integer_c_int8_t_5(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_5

  subroutine fpAllocate__integer_c_int8_t_5(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_5

  subroutine fpDeallocate__integer_c_int8_t_5(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,5)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,5) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_5

  function mxArrayHeader__integer_c_int8_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,5)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,5)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,5) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,5) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_5

  subroutine fpGetPr__integer_c_int16_t_5(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_5

  subroutine fpGetPi__integer_c_int16_t_5(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_5

  subroutine fpAllocate__integer_c_int16_t_5(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,5)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_5

  subroutine fpDeallocate__integer_c_int16_t_5(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,5)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,5) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_5

  function mxArrayHeader__integer_c_int16_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,5)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,5)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,5) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,5) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_5

  subroutine fpGetPr__real_c_double_2(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_2

  subroutine fpGetPi__real_c_double_2(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_2

  subroutine fpAllocate__real_c_double_2(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,2)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_2

  subroutine fpDeallocate__real_c_double_2(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,2)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,2) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_2

  function mxArrayHeader__real_c_double_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,2)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,2)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,2) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,2) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_2

  subroutine fpGetPr__integer_c_int16_t_6(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_6

  subroutine fpGetPi__integer_c_int16_t_6(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_6

  subroutine fpAllocate__integer_c_int16_t_6(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,6)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_6

  subroutine fpDeallocate__integer_c_int16_t_6(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,6)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,6) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_6

  function mxArrayHeader__integer_c_int16_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,6)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,6)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,6) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,6) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_6

  subroutine fpGetPr__real_c_double_3(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_3

  subroutine fpGetPi__real_c_double_3(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_3

  subroutine fpAllocate__real_c_double_3(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,3)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_3

  subroutine fpDeallocate__real_c_double_3(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,3)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,3) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_3

  function mxArrayHeader__real_c_double_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,3)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,3)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,3) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,3) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_3

  subroutine fpGetPr__integer_c_int8_t_2(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_2

  subroutine fpGetPi__integer_c_int8_t_2(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_2

  subroutine fpAllocate__integer_c_int8_t_2(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_2

  subroutine fpDeallocate__integer_c_int8_t_2(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,2)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,2) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_2

  function mxArrayHeader__integer_c_int8_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,2)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,2)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,2) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,2) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_2

  subroutine fpGetPr__real_c_double_0(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_0

  subroutine fpGetPi__real_c_double_0(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_0

  subroutine fpAllocate__real_c_double_0(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,0)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__real_c_double_0

  subroutine fpDeallocate__real_c_double_0(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,0)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX(fp,1,0) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_0

  function mxArrayHeader__real_c_double_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,0)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,0)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_double_0

  subroutine fpGetPr__integer_c_int8_t_3(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_3

  subroutine fpGetPi__integer_c_int8_t_3(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_3

  subroutine fpAllocate__integer_c_int8_t_3(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,3)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_3

  subroutine fpDeallocate__integer_c_int8_t_3(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,3)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,3) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_3

  function mxArrayHeader__integer_c_int8_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,3)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,3)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,3) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,3) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_3

  subroutine fpGetPr__integer_c_int16_t_0(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_0

  subroutine fpGetPi__integer_c_int16_t_0(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_0

  subroutine fpAllocate__integer_c_int16_t_0(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int16_t_0

  subroutine fpDeallocate__integer_c_int16_t_0(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,0)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX(fp,1,0) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_0

  function mxArrayHeader__integer_c_int16_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,0)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,0)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int16_t_0

  subroutine fpGetPr__real_c_double_1(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_1

  subroutine fpGetPi__real_c_double_1(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_1

  subroutine fpAllocate__real_c_double_1(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,1)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_1

  subroutine fpDeallocate__real_c_double_1(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,1)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_1

  function mxArrayHeader__real_c_double_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,1)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,1)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_double_1

  subroutine fpGetPr__integer_c_int8_t_0(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_0

  subroutine fpGetPi__integer_c_int8_t_0(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_0

  subroutine fpAllocate__integer_c_int8_t_0(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,0)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int8_t_0

  subroutine fpDeallocate__integer_c_int8_t_0(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,0)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX(fp,1,0) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_0

  function mxArrayHeader__integer_c_int8_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,0)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,0)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int8_t_0

  subroutine fpGetPr__integer_c_int16_t_1(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_1

  subroutine fpGetPi__integer_c_int16_t_1(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_1

  subroutine fpAllocate__integer_c_int16_t_1(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_1

  subroutine fpDeallocate__integer_c_int16_t_1(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,1)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_1

  function mxArrayHeader__integer_c_int16_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,1)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,1)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int16_t_1

  subroutine fpGetPr__real_c_double_6(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_6

  subroutine fpGetPi__real_c_double_6(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_6

  subroutine fpAllocate__real_c_double_6(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX(fp,:,6)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_6

  subroutine fpDeallocate__real_c_double_6(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX(fp,:,6)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,6) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_6

  function mxArrayHeader__real_c_double_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX(A,:,6)
    real(kind=c_double), optional, intent(in) :: REPIDX(B,:,6)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,6) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,6) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_6

  subroutine fpGetPr__integer_c_int8_t_1(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_1

  subroutine fpGetPi__integer_c_int8_t_1(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( mxIsInt8(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_1

  subroutine fpAllocate__integer_c_int8_t_1(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX(fp,:,1)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_1

  subroutine fpDeallocate__integer_c_int8_t_1(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX(fp,:,1)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_1

  function mxArrayHeader__integer_c_int8_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX(A,:,1)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX(B,:,1)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int8_t_1

  subroutine fpGetPr__integer_c_int16_t_2(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_2

  subroutine fpGetPi__integer_c_int16_t_2(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( mxIsInt16(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_2

  subroutine fpAllocate__integer_c_int16_t_2(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX(fp,:,2)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_2

  subroutine fpDeallocate__integer_c_int16_t_2(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX(fp,:,2)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX(fp,1,2) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_2

  function mxArrayHeader__integer_c_int16_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX(A,:,2)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX(B,:,2)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX(A,1,2) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX(B,1,2) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_2

!
!-----
! fpGetCells
!-----
!
  subroutine fpGetCells__5( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,5)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(5)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 5 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__5
  subroutine fpGetCells__2( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,2)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(2)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 2 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__2
  subroutine fpGetCells__3( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,3)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(3)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 3 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__3
  subroutine fpGetCells__6( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,6)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(6)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 6 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__6
  subroutine fpGetCells__7( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,7)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(7)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 7 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__7
  subroutine fpGetCells__1( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,1)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(1)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dimz(1) = N
        call c_f_pointer(ppc, fp, dimz)
  end subroutine fpGetCells__1
  subroutine fpGetCells__4( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX(fp,:,4)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(4)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 4 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__4
    
!
!-----
! Non-templated subroutines
!-----
!
  function fpGetDimensions( mx ) result(fp)
    implicit none
    mwSize, pointer :: fp(:)
!-ARG
    mwPointer, intent(in) :: mx
!-LOC
    mwSize :: ndim(1)
    mwPointer :: dims
    type(c_ptr) :: dimsc
!-----
    ndim(1) = mxGetNumberOfDimensions( mx )
    dims = mxGetDimensions( mx )
    dimsc = transfer(dims, dimsc)
    call c_f_pointer(dimsc, fp, ndim)
  end function fpGetDimensions

  function uppercase(string) result(upper)
    character(len=*), intent(in) :: string
    character(len=len(string)) :: upper
    integer :: j
    do j = 1,len(string)
        if(string(j:j) >= "a" .and. string(j:j) <= "z") then
            upper(j:j) = achar(iachar(string(j:j)) - 32)
        else
            upper(j:j) = string(j:j)
        end if
    enddo
  end function uppercase

end module MatlabAPImx


