!PyF95.start
!...............................................................................
!.
!. This code was pre-parsed by PyF95++, a block parser and code generator.
!. Website: http://blockit.sourceforge.net/
!. Wiki: http://blockit.sourceforge.net/wiki.html
!. Download: http://blockit.sourceforge.net/download.html
!.
!................................................................................
!PyF95.hash: d0054f7fdaa65d7a3f15ccbb64fd25d9e6fbf5894c6a70dbb98478be55f337ef
!PyF95.symbol: MatlabAPImx
!PyF95.symbol: fpGetPr|MatlabAPImx
!PyF95.symbol: uppercase|MatlabAPImx
!PyF95.symbol: fpGetCells|MatlabAPImx
!PyF95.symbol: fpGetDimensions|MatlabAPImx
!PyF95.symbol: template_4353578704|MatlabAPImx
!PyF95.symbol: template_4357092560|MatlabAPImx
!PyF95.symbol: template_4357092560_7|MatlabAPImx
!PyF95.symbol: template_4357092560_5|MatlabAPImx
!PyF95.symbol: template_4357092560_2|MatlabAPImx
!PyF95.symbol: template_4357092560_4|MatlabAPImx
!PyF95.symbol: template_4357092560_3|MatlabAPImx
!PyF95.symbol: template_4357092560_1|MatlabAPImx
!PyF95.symbol: template_4357092560_6|MatlabAPImx
!PyF95.symbol: fpGetPr_|template_4353578704|MatlabAPImx
!PyF95.symbol: fpGetPi_|template_4353578704|MatlabAPImx
!PyF95.symbol: fpGetCells_|template_4357092560|MatlabAPImx
!PyF95.symbol: fpAllocate_|template_4353578704|MatlabAPImx
!PyF95.symbol: fpDeallocate_|template_4353578704|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader_|template_4353578704|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpGetCells__3|template_4357092560_3|MatlabAPImx
!PyF95.symbol: fpGetCells__1|template_4357092560_1|MatlabAPImx
!PyF95.symbol: fpGetCells__6|template_4357092560_6|MatlabAPImx
!PyF95.symbol: fpGetCells__5|template_4357092560_5|MatlabAPImx
!PyF95.symbol: fpGetCells__4|template_4357092560_4|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetCells__7|template_4357092560_7|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetCells__2|template_4357092560_2|MatlabAPImx
!PyF95.symbol: template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4355931088|fpGetPi_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4354107024|fpGetPr_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4356846608|fpGetPi_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4355452624|fpGetPr_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4357129296|fpGetCells_|template_4357092560|MatlabAPImx
!PyF95.symbol: special_4356917840|fpAllocate_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4356848912|fpAllocate_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4356966288|fpDeallocate_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4357015120|mxArrayHeader_|template_4353578704|MatlabAPImx
!PyF95.symbol: special_4357017360|mxArrayHeader_|template_4353578704|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpGetPi__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpGetPr__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpAllocate__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4357129296_5_4372279184|fpGetCells__5|template_4357092560_5|MatlabAPImx
!PyF95.symbol: special_4357129296_2_4372221520|fpGetCells__2|template_4357092560_2|MatlabAPImx
!PyF95.symbol: special_4357129296_3_4372221648|fpGetCells__3|template_4357092560_3|MatlabAPImx
!PyF95.symbol: special_4357129296_4_4371741584|fpGetCells__4|template_4357092560_4|MatlabAPImx
!PyF95.symbol: special_4357129296_1_4372016848|fpGetCells__1|template_4357092560_1|MatlabAPImx
!PyF95.symbol: special_4357129296_6_4372108624|fpGetCells__6|template_4357092560_6|MatlabAPImx
!PyF95.symbol: special_4357129296_7_4372016592|fpGetCells__7|template_4357092560_7|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpGetPi__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: fpGetPr__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpAllocate__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: fpDeallocate__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: mxArrayHeader__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_0_4362889040|fpGetPi__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_2_4362164688|fpGetPr__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_4_4360314192|fpGetPi__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_6_4366909136|fpGetPi__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_1_4363248336|fpGetPr__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_5_4370279312|fpGetPr__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_1_4363202256|fpGetPr__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_4_4360101456|fpGetPr__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_2_4362210768|fpGetPi__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_4_4360430608|fpGetPi__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_6_4366626448|fpGetPr__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_0_4362889744|fpGetPr__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_2_4361922576|fpGetPr__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_0_4362643536|fpGetPr__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_5_4370592080|fpGetPi__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_3_4363698384|fpGetPi__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_5_4370516624|fpGetPi__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_6_4366947344|fpGetPi__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_5_4370517328|fpGetPr__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_6_4366863952|fpGetPr__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_2_4362163984|fpGetPi__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_0_4362931728|fpGetPi__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_float_3_4363365712|fpGetPr__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_1_4363202384|fpGetPi__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_3_4363611216|fpGetPr__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_float_3_4363610512|fpGetPi__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_float_4_4360313936|fpGetPr__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_float_1_4363319056|fpGetPi__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_6_4364032400|fpGetPi__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_3_4363644240|fpAllocate__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_4_4361205712|fpGetPr__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_6_4363978128|fpGetPr__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_5_4370550352|fpAllocate__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_0_4366512592|fpGetPi__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_4_4361447120|fpGetPi__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_2_4368338064|fpGetPi__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_4_4360430800|fpAllocate__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_6_4363977424|fpGetPi__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_5_4370656528|fpAllocate__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_5_4360764752|fpGetPi__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_4_4361447824|fpGetPr__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_2_4368409616|fpGetPi__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_6_4363753040|fpGetPr__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_6_4366909264|fpAllocate__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_3_4367285136|fpGetPi__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_3_4363754512|fpAllocate__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_5_4360713872|fpGetPi__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_1_4363365648|fpAllocate__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_3_4367026256|fpGetPr__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_4_4360482768|fpAllocate__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_6_4367027728|fpAllocate__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_0_4366513296|fpGetPr__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_3_4367234256|fpGetPi__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4355931088_real_c_double_1_4365330256|fpGetPi__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_2_4368338704|fpGetPr__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_1_4363319248|fpAllocate__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_0_4362931856|fpAllocate__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_2_4362312080|fpAllocate__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_5_4360481360|fpGetPr__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_1_4365514768|fpGetPi__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_1_4365444112|fpGetPr__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_3_4367234960|fpGetPr__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_float_0_4363028944|fpAllocate__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_float_2_4362210896|fpAllocate__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_0_4366281104|fpGetPr__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_4_4361489808|fpGetPi__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_2_4368071952|fpGetPr__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4355452624_real_c_double_1_4365214416|fpGetPr__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4354107024_real_c_double_5_4360714576|fpGetPr__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4356846608_real_c_double_0_4366559376|fpGetPi__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_1_4363415312|fpDeallocate__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_0_4363090256|fpDeallocate__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_6_4367076752|fpDeallocate__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_3_4363803536|fpDeallocate__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_4_4360539984|fpDeallocate__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_5_4370721936|fpDeallocate__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_float_2_4362361104|fpDeallocate__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_5_4360764880|fpAllocate__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_5_4370765456|mxArrayHeader__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_5_4370766544|mxArrayHeader__real_c_float_5|template_4353578704_real_c_float_5|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_3_4363868624|mxArrayHeader__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_6_4364087120|fpAllocate__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_2_4368457488|fpAllocate__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_1_4365557200|fpAllocate__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_1_4363464656|mxArrayHeader__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_2_4368370704|fpAllocate__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_6_4367129552|mxArrayHeader__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_5_4360861968|fpAllocate__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_4_4360595792|mxArrayHeader__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_0_4363147152|mxArrayHeader__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_0_4366626384|fpAllocate__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_0_4363148560|mxArrayHeader__real_c_float_0|template_4353578704_real_c_float_0|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_4_4361591120|fpAllocate__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_3_4363870032|mxArrayHeader__real_c_float_3|template_4353578704_real_c_float_3|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_4_4360596880|mxArrayHeader__real_c_float_4|template_4353578704_real_c_float_4|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_2_4362426192|mxArrayHeader__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_float_1_4363464016|mxArrayHeader__real_c_float_1|template_4353578704_real_c_float_1|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_3_4367285264|fpAllocate__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_0_4366559504|fpAllocate__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_1_4365514896|fpAllocate__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_6_4364032528|fpAllocate__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_2_4362427600|mxArrayHeader__real_c_float_2|template_4353578704_real_c_float_2|MatlabAPImx
!PyF95.symbol: special_4356848912_real_c_double_4_4361489936|fpAllocate__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4356917840_real_c_double_3_4367386448|fpAllocate__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_float_6_4367128464|mxArrayHeader__real_c_float_6|template_4353578704_real_c_float_6|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_6_4364195024|fpDeallocate__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_4_4361648336|fpDeallocate__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_3_4367451856|fpDeallocate__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_2_4368522896|fpDeallocate__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_5_4360915088|fpDeallocate__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_1_4365614928|fpDeallocate__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4356966288_real_c_double_0_4366684112|fpDeallocate__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_4_4361717520|mxArrayHeader__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_2_4368582800|mxArrayHeader__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_0_4366732688|mxArrayHeader__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_2_4368583888|mxArrayHeader__real_c_double_2|template_4353578704_real_c_double_2|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_6_4364253328|mxArrayHeader__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_0_4366788496|mxArrayHeader__real_c_double_0|template_4353578704_real_c_double_0|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_1_4365655312|mxArrayHeader__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_5_4360981584|mxArrayHeader__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_6_4364197648|mxArrayHeader__real_c_double_6|template_4353578704_real_c_double_6|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_5_4360980176|mxArrayHeader__real_c_double_5|template_4353578704_real_c_double_5|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_1_4365707024|mxArrayHeader__real_c_double_1|template_4353578704_real_c_double_1|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_4_4361718928|mxArrayHeader__real_c_double_4|template_4353578704_real_c_double_4|MatlabAPImx
!PyF95.symbol: special_4357015120_real_c_double_3_4367516944|mxArrayHeader__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4357017360_real_c_double_3_4367518352|mxArrayHeader__real_c_double_3|template_4353578704_real_c_double_3|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_6_4371671248|fpGetPi__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_3_4357852880|fpGetPi__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_5_4369404880|fpGetPi__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_6_4371621008|fpGetPr__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_4_4359584848|fpGetPr__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_2_4358651600|fpGetPr__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_1_4356778768|fpGetPi__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_2_4358910288|fpGetPr__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_2_4358972688|fpGetPi__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_3_4357790352|fpGetPr__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_5_4369405456|fpGetPr__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_1_4356586256|fpGetPr__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_0_4357531280|fpGetPi__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_4_4359364368|fpGetPr__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_3_4357581200|fpGetPr__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_3_4357789776|fpGetPi__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_4_4359701584|fpGetPi__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_0_4357418640|fpGetPr__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_0_4357477328|fpGetPr__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_4_4359585232|fpGetPi__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_1_4353747280|fpGetPi__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_6_4371620432|fpGetPi__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int8_t_5_4369472080|fpGetPi__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_6_4371399696|fpGetPr__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int8_t_1_4353746128|fpGetPr__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_0_4357418768|fpGetPi__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int8_t_5_4369208720|fpGetPr__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int8_t_2_4358868624|fpGetPi__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_5_4365065104|fpGetPr__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_6_4367568720|fpGetPr__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_2_4358515024|fpGetPr__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_3_4361872656|fpGetPi__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_1_4364328272|fpGetPr__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_2_4371254480|fpGetPr__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_0_4365823888|fpGetPi__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_3_4370888016|fpGetPr__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_6_4367742480|fpGetPr__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_0_4357531344|fpAllocate__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_2_4358514448|fpGetPi__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_0_4369945872|fpGetPr__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_2_4356074832|fpGetPr__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_3_4359263824|fpGetPi__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_0_4359996816|fpGetPi__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_5_4364706960|fpGetPr__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_6_4361085328|fpGetPr__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_2_4357094096|fpGetPr__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_1_4362597712|fpGetPi__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_5_4368704784|fpGetPi__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_3_4370929936|fpGetPi__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_4_4358181520|fpGetPr__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_2_4359027344|fpAllocate__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_0_4365793680|fpGetPi__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_2_4371004368|fpGetPr__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_4_4358139856|fpGetPi__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_3_4359264400|fpGetPr__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_5_4365107024|fpGetPi__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_0_4370154192|fpGetPi__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_2_4358972752|fpAllocate__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_4_4359701648|fpAllocate__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_6_4367334864|fpGetPr__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_4_4369538320|fpGetPr__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_6_4367568144|fpGetPi__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_1_4356075408|fpAllocate__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_6_4367967888|fpGetPr__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_6_4361151696|fpGetPi__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_0_4365794256|fpGetPr__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_3_4357852944|fpAllocate__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_1_4368805328|fpGetPr__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_4_4366122768|fpGetPi__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_2_4358589712|fpGetPi__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_0_4359747408|fpGetPr__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_5_4368705360|fpGetPr__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_3_4359322704|fpGetPi__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_5_4364485776|fpGetPr__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_1_4364327696|fpGetPi__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_1_4364419600|fpGetPi__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_4_4359749520|fpAllocate__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_1_4364087184|fpGetPr__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_1_4362489680|fpGetPi__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_0_4370154768|fpGetPr__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_1_4369146384|fpGetPi__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_1_4369096336|fpGetPi__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_5_4368456080|fpGetPr__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_6_4360821456|fpGetPr__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_3_4357966352|fpAllocate__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_6_4371742224|fpAllocate__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_3_4370887440|fpGetPi__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_0_4360035216|fpGetPi__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_0_4357581840|fpAllocate__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_6_4367663312|fpGetPi__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_4_4366235280|fpGetPi__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_1_4362310608|fpGetPr__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_2_4357136016|fpGetPi__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_3_4361546512|fpGetPr__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_5_4364757072|fpGetPi__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_5_4369472144|fpAllocate__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_3_4361768720|fpGetPi__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_3_4370655056|fpGetPr__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_6_4367967312|fpGetPi__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_6_4368022096|fpGetPi__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_4_4369875600|fpGetPi__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_2_4357093520|fpGetPi__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_2_4358297808|fpGetPr__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_5_4364819216|fpGetPr__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_2_4371325328|fpGetPi__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int16_t_4_4369800080|fpGetPi__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int64_t_4_4358260176|fpGetPi__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_5_4364706384|fpGetPi__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_1_4362527248|fpGetPr__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int16_t_0_4365557264|fpGetPr__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int32_t_0_4370204880|fpGetPi__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_1_4356778832|fpAllocate__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_4_4369800656|fpGetPr__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int64_t_0_4359997392|fpGetPr__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int16_t_3_4361810384|fpGetPr__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int8_t_5_4369538960|fpAllocate__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_4_4366173264|fpGetPr__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int32_t_4_4366047120|fpGetPr__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_6_4361039568|fpGetPi__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4356846608_integer_c_int16_t_5_4368747280|fpGetPi__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_4_4357964368|fpGetPr__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4355452624_integer_c_int64_t_3_4359026704|fpGetPr__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4354107024_integer_c_int32_t_1_4369059408|fpGetPr__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int32_t_2_4371253904|fpGetPi__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int8_t_6_4371671312|fpAllocate__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4355931088_integer_c_int64_t_5_4365064528|fpGetPi__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_5_4369650832|fpDeallocate__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_4_4359831184|fpDeallocate__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_6_4371795856|fpDeallocate__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_1_4356673872|fpDeallocate__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_3_4358015248|fpDeallocate__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_0_4357639696|fpDeallocate__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int8_t_2_4359081808|fpDeallocate__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_1_4356706384|mxArrayHeader__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_0_4370279952|fpAllocate__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_3_4370930000|fpAllocate__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_4_4358298448|fpAllocate__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_6_4367629456|fpAllocate__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_6_4361206352|fpAllocate__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_6_4371887952|mxArrayHeader__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_1_4364487760|fpAllocate__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_2_4359146960|mxArrayHeader__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_3_4361923216|fpAllocate__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_3_4358088592|mxArrayHeader__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_6_4368022160|fpAllocate__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_1_4369210704|fpAllocate__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_4_4359888144|mxArrayHeader__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_3_4359411600|fpAllocate__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_4_4359888336|mxArrayHeader__integer_c_int8_t_4|template_4353578704_integer_c_int8_t_4|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_4_4369829520|fpAllocate__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_3_4358090064|mxArrayHeader__integer_c_int8_t_3|template_4353578704_integer_c_int8_t_3|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_3_4359322768|fpAllocate__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_3_4361872720|fpAllocate__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_6_4367744592|fpAllocate__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_5_4364819856|fpAllocate__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_5_4368860752|fpAllocate__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_0_4357684048|mxArrayHeader__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_2_4357136080|fpAllocate__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_2_4357245392|fpAllocate__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_5_4369709264|mxArrayHeader__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_5_4365216400|fpAllocate__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_6_4371840336|mxArrayHeader__integer_c_int8_t_6|template_4353578704_integer_c_int8_t_6|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_5_4364757136|fpAllocate__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_4_4358260240|fpAllocate__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_0_4360035280|fpAllocate__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_3_4371005008|fpAllocate__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_5_4365107088|fpAllocate__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_2_4371401680|fpAllocate__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_0_4365941456|fpAllocate__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_1_4362644176|fpAllocate__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_0_4370204944|fpAllocate__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_0_4357685136|mxArrayHeader__integer_c_int8_t_0|template_4353578704_integer_c_int8_t_0|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_1_4356709904|mxArrayHeader__integer_c_int8_t_1|template_4353578704_integer_c_int8_t_1|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_0_4360140496|fpAllocate__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_1_4369096464|fpAllocate__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_1_4364365328|fpAllocate__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_2_4358650512|fpAllocate__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_4_4366235344|fpAllocate__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_1_4362597776|fpAllocate__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_4_4366281744|fpAllocate__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_5_4368747344|fpAllocate__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int8_t_5_4369653584|mxArrayHeader__integer_c_int8_t_5|template_4353578704_integer_c_int8_t_5|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int8_t_2_4359147152|mxArrayHeader__integer_c_int8_t_2|template_4353578704_integer_c_int8_t_2|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int64_t_2_4358694992|fpAllocate__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int16_t_0_4365823824|fpAllocate__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int64_t_6_4361151760|fpAllocate__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4356848912_integer_c_int32_t_2_4371283344|fpAllocate__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int16_t_4_4369947856|fpAllocate__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4356917840_integer_c_int32_t_6_4368072592|fpAllocate__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_6_4368200848|fpDeallocate__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_1_4364540752|fpDeallocate__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_4_4358364496|fpDeallocate__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_4_4366327312|fpDeallocate__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_6_4361264912|fpDeallocate__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_3_4361981776|fpDeallocate__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_2_4371450576|fpDeallocate__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_3_4359480976|fpDeallocate__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_3_4371054544|fpDeallocate__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_5_4365269392|fpDeallocate__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_5_4368921936|fpDeallocate__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_0_4370333584|fpDeallocate__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_6_4367801680|fpDeallocate__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_5_4364873488|fpDeallocate__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_2_4358760272|fpDeallocate__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_0_4360213968|fpDeallocate__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_4_4369996752|fpDeallocate__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_0_4365998544|fpDeallocate__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int16_t_2_4357290192|fpDeallocate__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int32_t_1_4369267792|fpDeallocate__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4356966288_integer_c_int64_t_1_4362715024|fpDeallocate__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_4_4356426000|mxArrayHeader__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_0_4366048784|mxArrayHeader__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_1_4362780368|mxArrayHeader__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_0_4366047312|mxArrayHeader__integer_c_int16_t_0|template_4353578704_integer_c_int16_t_0|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_5_4368980368|mxArrayHeader__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_5_4368924560|mxArrayHeader__integer_c_int16_t_5|template_4353578704_integer_c_int16_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_3_4362046928|mxArrayHeader__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_3_4362047120|mxArrayHeader__integer_c_int16_t_3|template_4353578704_integer_c_int16_t_3|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_2_4371509008|mxArrayHeader__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_4_4354948048|mxArrayHeader__integer_c_int32_t_4|template_4353578704_integer_c_int32_t_4|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_1_4364585424|mxArrayHeader__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_0_4370437968|mxArrayHeader__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_2_4358809040|mxArrayHeader__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_4_4358426448|mxArrayHeader__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_5_4364994256|mxArrayHeader__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_3_4359525648|mxArrayHeader__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_6_4367854544|mxArrayHeader__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_4_4358426256|mxArrayHeader__integer_c_int64_t_4|template_4353578704_integer_c_int64_t_4|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_1_4369312464|mxArrayHeader__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_0_4360268304|mxArrayHeader__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_5_4364930256|mxArrayHeader__integer_c_int32_t_5|template_4353578704_integer_c_int32_t_5|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_6_4361338448|mxArrayHeader__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_2_4357356816|mxArrayHeader__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_3_4371111312|mxArrayHeader__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_6_4361338256|mxArrayHeader__integer_c_int64_t_6|template_4353578704_integer_c_int64_t_6|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_4_4370045520|mxArrayHeader__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_6_4368203600|mxArrayHeader__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int16_t_2_4357355344|mxArrayHeader__integer_c_int16_t_2|template_4353578704_integer_c_int16_t_2|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_1_4369312656|mxArrayHeader__integer_c_int32_t_1|template_4353578704_integer_c_int32_t_1|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_0_4370390352|mxArrayHeader__integer_c_int32_t_0|template_4353578704_integer_c_int32_t_0|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_4_4370046928|mxArrayHeader__integer_c_int16_t_4|template_4353578704_integer_c_int16_t_4|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_1_4364586960|mxArrayHeader__integer_c_int16_t_1|template_4353578704_integer_c_int16_t_1|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_3_4359527120|mxArrayHeader__integer_c_int64_t_3|template_4353578704_integer_c_int64_t_3|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_3_4371163024|mxArrayHeader__integer_c_int32_t_3|template_4353578704_integer_c_int32_t_3|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int32_t_6_4368246992|mxArrayHeader__integer_c_int32_t_6|template_4353578704_integer_c_int32_t_6|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_5_4365331920|mxArrayHeader__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_0_4360266832|mxArrayHeader__integer_c_int64_t_0|template_4353578704_integer_c_int64_t_0|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_5_4365330448|mxArrayHeader__integer_c_int64_t_5|template_4353578704_integer_c_int64_t_5|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int64_t_2_4358810512|mxArrayHeader__integer_c_int64_t_2|template_4353578704_integer_c_int64_t_2|MatlabAPImx
!PyF95.symbol: special_4357017360_integer_c_int16_t_6_4367854736|mxArrayHeader__integer_c_int16_t_6|template_4353578704_integer_c_int16_t_6|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int32_t_2_4371507536|mxArrayHeader__integer_c_int32_t_2|template_4353578704_integer_c_int32_t_2|MatlabAPImx
!PyF95.symbol: special_4357015120_integer_c_int64_t_1_4362780176|mxArrayHeader__integer_c_int64_t_1|template_4353578704_integer_c_int64_t_1|MatlabAPImx
!PyF95.end
!*************************************************************************************
! 
!  MATLAB (R) is a trademark of The Mathworks (R) Corporation
! 
!  Copyright:   (c) 2009, 2011 by James Tursa
!  Copyright:   (c) 2012 by Robin Ince
!  All Rights Reserved
! 
!   This code uses the BSD License:
! 
!   Redistribution and use in source and binary forms, with or without 
!   modification, are permitted provided that the following conditions are 
!   met:
! 
!      * Redistributions of source code must retain the above copyright 
!        notice, this list of conditions and the following disclaimer.
!      * Redistributions in binary form must reproduce the above copyright 
!        notice, this list of conditions and the following disclaimer in 
!        the documentation and/or other materials provided with the distribution
!       
!   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
!   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
!   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
!   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
!   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
!   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
!   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
!   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
!   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
!   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
!   POSSIBILITY OF SUCH DAMAGE.
#include "fintrf.h"
#include "repidx.h"

module MatlabAPImx
  use iso_c_binding
  implicit none

#include "mxInterface.inc"

  ! instantiate templates from fpGetPr
  interface fpGetPr
    module procedure fpGetPr__real_c_double_0
    module procedure fpGetPr__real_c_double_1
    module procedure fpGetPr__real_c_double_2
    module procedure fpGetPr__real_c_double_3
    module procedure fpGetPr__real_c_double_4
    module procedure fpGetPr__real_c_double_5
    module procedure fpGetPr__real_c_double_6
    !module procedure fpGetPr__real_c_double_7
    module procedure fpGetPr__real_c_float_0
    module procedure fpGetPr__real_c_float_1
    module procedure fpGetPr__real_c_float_2
    module procedure fpGetPr__real_c_float_3
    module procedure fpGetPr__real_c_float_4
    module procedure fpGetPr__real_c_float_5
    module procedure fpGetPr__real_c_float_6
    !module procedure fpGetPr__real_c_float_7
    module procedure fpGetPr__integer_c_int32_t_0
    module procedure fpGetPr__integer_c_int32_t_1
    module procedure fpGetPr__integer_c_int32_t_2
    module procedure fpGetPr__integer_c_int32_t_3
    module procedure fpGetPr__integer_c_int32_t_4
    module procedure fpGetPr__integer_c_int32_t_5
    module procedure fpGetPr__integer_c_int32_t_6
    !module procedure fpGetPr__integer_c_int32_t_7
    module procedure fpGetPr__integer_c_int64_t_0
    module procedure fpGetPr__integer_c_int64_t_1
    module procedure fpGetPr__integer_c_int64_t_2
    module procedure fpGetPr__integer_c_int64_t_3
    module procedure fpGetPr__integer_c_int64_t_4
    module procedure fpGetPr__integer_c_int64_t_5
    module procedure fpGetPr__integer_c_int64_t_6
    !module procedure fpGetPr__integer_c_int64_t_7
    module procedure fpGetPr__integer_c_int16_t_0
    module procedure fpGetPr__integer_c_int16_t_1
    module procedure fpGetPr__integer_c_int16_t_2
    module procedure fpGetPr__integer_c_int16_t_3
    module procedure fpGetPr__integer_c_int16_t_4
    module procedure fpGetPr__integer_c_int16_t_5
    module procedure fpGetPr__integer_c_int16_t_6
    !module procedure fpGetPr__integer_c_int16_t_7
    module procedure fpGetPr__integer_c_int8_t_0
    module procedure fpGetPr__integer_c_int8_t_1
    module procedure fpGetPr__integer_c_int8_t_2
    module procedure fpGetPr__integer_c_int8_t_3
    module procedure fpGetPr__integer_c_int8_t_4
    module procedure fpGetPr__integer_c_int8_t_5
    module procedure fpGetPr__integer_c_int8_t_6
    !module procedure fpGetPr__integer_c_int8_t_7

  end interface

  ! rank-only templates
  interface fpGetCells
    module procedure fpGetCells__1
    module procedure fpGetCells__2
    module procedure fpGetCells__3
    module procedure fpGetCells__4
    module procedure fpGetCells__5
    module procedure fpGetCells__6
    module procedure fpGetCells__7
  end interface

  ! AutoInterface will provide all other procedures
  !..............................................................................
  ! `AutoInterface` Generated Code Section
  !..............................................................................
  interface fpGetPi
    module procedure fpGetPi__integer_c_int16_t_4
    module procedure fpGetPi__integer_c_int16_t_5
    module procedure fpGetPi__integer_c_int16_t_6
    module procedure fpGetPi__integer_c_int16_t_0
    module procedure fpGetPi__integer_c_int16_t_1
    module procedure fpGetPi__integer_c_int16_t_2
    module procedure fpGetPi__integer_c_int16_t_3
    module procedure fpGetPi__real_c_double_6
    module procedure fpGetPi__integer_c_int8_t_0
    module procedure fpGetPi__integer_c_int8_t_1
    module procedure fpGetPi__integer_c_int8_t_2
    module procedure fpGetPi__integer_c_int8_t_3
    module procedure fpGetPi__integer_c_int8_t_4
    module procedure fpGetPi__integer_c_int8_t_5
    module procedure fpGetPi__integer_c_int8_t_6
    module procedure fpGetPi__real_c_float_2
    module procedure fpGetPi__real_c_float_3
    module procedure fpGetPi__real_c_float_0
    module procedure fpGetPi__real_c_float_1
    module procedure fpGetPi__real_c_float_6
    module procedure fpGetPi__real_c_float_4
    module procedure fpGetPi__integer_c_int64_t_3
    module procedure fpGetPi__integer_c_int64_t_2
    module procedure fpGetPi__integer_c_int64_t_1
    module procedure fpGetPi__integer_c_int64_t_0
    module procedure fpGetPi__integer_c_int64_t_6
    module procedure fpGetPi__integer_c_int64_t_5
    module procedure fpGetPi__integer_c_int64_t_4
    module procedure fpGetPi__integer_c_int32_t_2
    module procedure fpGetPi__integer_c_int32_t_3
    module procedure fpGetPi__integer_c_int32_t_0
    module procedure fpGetPi__integer_c_int32_t_1
    module procedure fpGetPi__integer_c_int32_t_6
    module procedure fpGetPi__integer_c_int32_t_4
    module procedure fpGetPi__integer_c_int32_t_5
    module procedure fpGetPi__real_c_double_0
    module procedure fpGetPi__real_c_double_1
    module procedure fpGetPi__real_c_double_2
    module procedure fpGetPi__real_c_double_3
    module procedure fpGetPi__real_c_double_4
    module procedure fpGetPi__real_c_double_5
    module procedure fpGetPi__real_c_float_5
  end interface

  interface mxArrayHeader
    module procedure mxArrayHeader__integer_c_int16_t_4
    module procedure mxArrayHeader__integer_c_int16_t_5
    module procedure mxArrayHeader__integer_c_int16_t_6
    module procedure mxArrayHeader__integer_c_int16_t_0
    module procedure mxArrayHeader__integer_c_int16_t_1
    module procedure mxArrayHeader__integer_c_int16_t_2
    module procedure mxArrayHeader__integer_c_int16_t_3
    module procedure mxArrayHeader__real_c_double_6
    module procedure mxArrayHeader__integer_c_int8_t_0
    module procedure mxArrayHeader__integer_c_int8_t_1
    module procedure mxArrayHeader__integer_c_int8_t_2
    module procedure mxArrayHeader__integer_c_int8_t_3
    module procedure mxArrayHeader__integer_c_int8_t_4
    module procedure mxArrayHeader__integer_c_int8_t_5
    module procedure mxArrayHeader__integer_c_int8_t_6
    module procedure mxArrayHeader__real_c_float_2
    module procedure mxArrayHeader__real_c_float_3
    module procedure mxArrayHeader__real_c_float_0
    module procedure mxArrayHeader__real_c_float_1
    module procedure mxArrayHeader__real_c_float_6
    module procedure mxArrayHeader__real_c_float_4
    module procedure mxArrayHeader__integer_c_int64_t_3
    module procedure mxArrayHeader__integer_c_int64_t_2
    module procedure mxArrayHeader__integer_c_int64_t_1
    module procedure mxArrayHeader__integer_c_int64_t_0
    module procedure mxArrayHeader__integer_c_int64_t_6
    module procedure mxArrayHeader__integer_c_int64_t_5
    module procedure mxArrayHeader__integer_c_int64_t_4
    module procedure mxArrayHeader__integer_c_int32_t_2
    module procedure mxArrayHeader__integer_c_int32_t_3
    module procedure mxArrayHeader__integer_c_int32_t_0
    module procedure mxArrayHeader__integer_c_int32_t_1
    module procedure mxArrayHeader__integer_c_int32_t_6
    module procedure mxArrayHeader__integer_c_int32_t_4
    module procedure mxArrayHeader__integer_c_int32_t_5
    module procedure mxArrayHeader__real_c_double_0
    module procedure mxArrayHeader__real_c_double_1
    module procedure mxArrayHeader__real_c_double_2
    module procedure mxArrayHeader__real_c_double_3
    module procedure mxArrayHeader__real_c_double_4
    module procedure mxArrayHeader__real_c_double_5
    module procedure mxArrayHeader__real_c_float_5
  end interface

  interface fpAllocate
    module procedure fpAllocate__integer_c_int16_t_4
    module procedure fpAllocate__integer_c_int16_t_5
    module procedure fpAllocate__integer_c_int16_t_6
    module procedure fpAllocate__integer_c_int16_t_0
    module procedure fpAllocate__integer_c_int16_t_1
    module procedure fpAllocate__integer_c_int16_t_2
    module procedure fpAllocate__integer_c_int16_t_3
    module procedure fpAllocate__real_c_double_6
    module procedure fpAllocate__integer_c_int8_t_0
    module procedure fpAllocate__integer_c_int8_t_1
    module procedure fpAllocate__integer_c_int8_t_2
    module procedure fpAllocate__integer_c_int8_t_3
    module procedure fpAllocate__integer_c_int8_t_4
    module procedure fpAllocate__integer_c_int8_t_5
    module procedure fpAllocate__integer_c_int8_t_6
    module procedure fpAllocate__real_c_float_2
    module procedure fpAllocate__real_c_float_3
    module procedure fpAllocate__real_c_float_0
    module procedure fpAllocate__real_c_float_1
    module procedure fpAllocate__real_c_float_6
    module procedure fpAllocate__real_c_float_4
    module procedure fpAllocate__integer_c_int64_t_3
    module procedure fpAllocate__integer_c_int64_t_2
    module procedure fpAllocate__integer_c_int64_t_1
    module procedure fpAllocate__integer_c_int64_t_0
    module procedure fpAllocate__integer_c_int64_t_6
    module procedure fpAllocate__integer_c_int64_t_5
    module procedure fpAllocate__integer_c_int64_t_4
    module procedure fpAllocate__integer_c_int32_t_2
    module procedure fpAllocate__integer_c_int32_t_3
    module procedure fpAllocate__integer_c_int32_t_0
    module procedure fpAllocate__integer_c_int32_t_1
    module procedure fpAllocate__integer_c_int32_t_6
    module procedure fpAllocate__integer_c_int32_t_4
    module procedure fpAllocate__integer_c_int32_t_5
    module procedure fpAllocate__real_c_double_0
    module procedure fpAllocate__real_c_double_1
    module procedure fpAllocate__real_c_double_2
    module procedure fpAllocate__real_c_double_3
    module procedure fpAllocate__real_c_double_4
    module procedure fpAllocate__real_c_double_5
    module procedure fpAllocate__real_c_float_5
  end interface

  interface fpDeallocate
    module procedure fpDeallocate__integer_c_int16_t_4
    module procedure fpDeallocate__integer_c_int16_t_5
    module procedure fpDeallocate__integer_c_int16_t_6
    module procedure fpDeallocate__integer_c_int16_t_0
    module procedure fpDeallocate__integer_c_int16_t_1
    module procedure fpDeallocate__integer_c_int16_t_2
    module procedure fpDeallocate__integer_c_int16_t_3
    module procedure fpDeallocate__real_c_double_6
    module procedure fpDeallocate__integer_c_int8_t_0
    module procedure fpDeallocate__integer_c_int8_t_1
    module procedure fpDeallocate__integer_c_int8_t_2
    module procedure fpDeallocate__integer_c_int8_t_3
    module procedure fpDeallocate__integer_c_int8_t_4
    module procedure fpDeallocate__integer_c_int8_t_5
    module procedure fpDeallocate__integer_c_int8_t_6
    module procedure fpDeallocate__real_c_float_2
    module procedure fpDeallocate__real_c_float_3
    module procedure fpDeallocate__real_c_float_0
    module procedure fpDeallocate__real_c_float_1
    module procedure fpDeallocate__real_c_float_6
    module procedure fpDeallocate__real_c_float_4
    module procedure fpDeallocate__integer_c_int64_t_3
    module procedure fpDeallocate__integer_c_int64_t_2
    module procedure fpDeallocate__integer_c_int64_t_1
    module procedure fpDeallocate__integer_c_int64_t_0
    module procedure fpDeallocate__integer_c_int64_t_6
    module procedure fpDeallocate__integer_c_int64_t_5
    module procedure fpDeallocate__integer_c_int64_t_4
    module procedure fpDeallocate__integer_c_int32_t_2
    module procedure fpDeallocate__integer_c_int32_t_3
    module procedure fpDeallocate__integer_c_int32_t_0
    module procedure fpDeallocate__integer_c_int32_t_1
    module procedure fpDeallocate__integer_c_int32_t_6
    module procedure fpDeallocate__integer_c_int32_t_4
    module procedure fpDeallocate__integer_c_int32_t_5
    module procedure fpDeallocate__real_c_double_0
    module procedure fpDeallocate__real_c_double_1
    module procedure fpDeallocate__real_c_double_2
    module procedure fpDeallocate__real_c_double_3
    module procedure fpDeallocate__real_c_double_4
    module procedure fpDeallocate__real_c_double_5
    module procedure fpDeallocate__real_c_float_5
  end interface

  !..............................................................................

  contains

  subroutine fpGetPr__integer_c_int8_t_6(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_6

  subroutine fpGetPi__integer_c_int8_t_6(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_6

  subroutine fpAllocate__integer_c_int8_t_6(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_6

  subroutine fpDeallocate__integer_c_int8_t_6(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_6

  function mxArrayHeader__integer_c_int8_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_6(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_6

  subroutine fpGetPr__integer_c_int32_t_2(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_2

  subroutine fpGetPi__integer_c_int32_t_2(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_2

  subroutine fpAllocate__integer_c_int32_t_2(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_2

  subroutine fpDeallocate__integer_c_int32_t_2(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_2

  function mxArrayHeader__integer_c_int32_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_2(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int32_t_2

  subroutine fpGetPr__integer_c_int32_t_3(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_3

  subroutine fpGetPi__integer_c_int32_t_3(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_3

  subroutine fpAllocate__integer_c_int32_t_3(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_3

  subroutine fpDeallocate__integer_c_int32_t_3(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_3

  function mxArrayHeader__integer_c_int32_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_3(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int32_t_3

  subroutine fpGetPr__real_c_float_5(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_5

  subroutine fpGetPi__real_c_float_5(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_5

  subroutine fpAllocate__real_c_float_5(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_5

  subroutine fpDeallocate__real_c_float_5(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_5

  function mxArrayHeader__real_c_float_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_5(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_float_5

  subroutine fpGetPr__integer_c_int32_t_0(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_0

  subroutine fpGetPi__integer_c_int32_t_0(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_0

  subroutine fpAllocate__integer_c_int32_t_0(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int32_t_0

  subroutine fpDeallocate__integer_c_int32_t_0(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_0

  function mxArrayHeader__integer_c_int32_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_0(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int32_t_0

  subroutine fpGetPr__integer_c_int16_t_4(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_4

  subroutine fpGetPi__integer_c_int16_t_4(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_4

  subroutine fpAllocate__integer_c_int16_t_4(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_4

  subroutine fpDeallocate__integer_c_int16_t_4(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_4

  function mxArrayHeader__integer_c_int16_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_4(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_4

  subroutine fpGetPr__integer_c_int8_t_5(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_5

  subroutine fpGetPi__integer_c_int8_t_5(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_5

  subroutine fpAllocate__integer_c_int8_t_5(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_5

  subroutine fpDeallocate__integer_c_int8_t_5(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_5

  function mxArrayHeader__integer_c_int8_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_5(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_5

  subroutine fpGetPr__integer_c_int32_t_1(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_1

  subroutine fpGetPi__integer_c_int32_t_1(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_1

  subroutine fpAllocate__integer_c_int32_t_1(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_1

  subroutine fpDeallocate__integer_c_int32_t_1(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_1

  function mxArrayHeader__integer_c_int32_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_1(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int32_t_1

  subroutine fpGetPr__integer_c_int16_t_5(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_5

  subroutine fpGetPi__integer_c_int16_t_5(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_5

  subroutine fpAllocate__integer_c_int16_t_5(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_5

  subroutine fpDeallocate__integer_c_int16_t_5(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_5

  function mxArrayHeader__integer_c_int16_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_5(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_5

  subroutine fpGetPr__real_c_double_2(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_2

  subroutine fpGetPi__real_c_double_2(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_2

  subroutine fpAllocate__real_c_double_2(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_2

  subroutine fpDeallocate__real_c_double_2(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_2

  function mxArrayHeader__real_c_double_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_2(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_2

  subroutine fpGetPr__integer_c_int32_t_6(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_6

  subroutine fpGetPi__integer_c_int32_t_6(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_6

  subroutine fpAllocate__integer_c_int32_t_6(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_6

  subroutine fpDeallocate__integer_c_int32_t_6(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_6

  function mxArrayHeader__integer_c_int32_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_6(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int32_t_6

  subroutine fpGetPr__integer_c_int16_t_6(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_6

  subroutine fpGetPi__integer_c_int16_t_6(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_6

  subroutine fpAllocate__integer_c_int16_t_6(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_6

  subroutine fpDeallocate__integer_c_int16_t_6(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_6

  function mxArrayHeader__integer_c_int16_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_6(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_6

  subroutine fpGetPr__real_c_double_3(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_3

  subroutine fpGetPi__real_c_double_3(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_3

  subroutine fpAllocate__real_c_double_3(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_3

  subroutine fpDeallocate__real_c_double_3(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_3

  function mxArrayHeader__real_c_double_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_3(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_3

  subroutine fpGetPr__real_c_float_6(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_6

  subroutine fpGetPi__real_c_float_6(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_6

  subroutine fpAllocate__real_c_float_6(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_6

  subroutine fpDeallocate__real_c_float_6(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_6

  function mxArrayHeader__real_c_float_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_6(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_float_6

  subroutine fpGetPr__real_c_double_0(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_0

  subroutine fpGetPi__real_c_double_0(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_0

  subroutine fpAllocate__real_c_double_0(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__real_c_double_0

  subroutine fpDeallocate__real_c_double_0(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_0

  function mxArrayHeader__real_c_double_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_0(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_double_0

  subroutine fpGetPr__integer_c_int32_t_4(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_4

  subroutine fpGetPi__integer_c_int32_t_4(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_4

  subroutine fpAllocate__integer_c_int32_t_4(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_4

  subroutine fpDeallocate__integer_c_int32_t_4(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_4

  function mxArrayHeader__integer_c_int32_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_4(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int32_t_4

  subroutine fpGetPr__integer_c_int16_t_0(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_0

  subroutine fpGetPi__integer_c_int16_t_0(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_0

  subroutine fpAllocate__integer_c_int16_t_0(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int16_t_0

  subroutine fpDeallocate__integer_c_int16_t_0(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_0

  function mxArrayHeader__integer_c_int16_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_0(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int16_t_0

  subroutine fpGetPr__real_c_double_1(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_1

  subroutine fpGetPi__real_c_double_1(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_1

  subroutine fpAllocate__real_c_double_1(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_1

  subroutine fpDeallocate__real_c_double_1(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_1

  function mxArrayHeader__real_c_double_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_1(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_double_1

  subroutine fpGetPr__integer_c_int64_t_5(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_5

  subroutine fpGetPi__integer_c_int64_t_5(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_5

  subroutine fpAllocate__integer_c_int64_t_5(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_5

  subroutine fpDeallocate__integer_c_int64_t_5(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_5

  function mxArrayHeader__integer_c_int64_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_5(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int64_t_5

  subroutine fpGetPr__integer_c_int32_t_5(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int32_t_5

  subroutine fpGetPi__integer_c_int32_t_5(fp, mx)
!-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt32(mx) == 1 .or. mxIsUint32(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int32_t_5

  subroutine fpAllocate__integer_c_int32_t_5(fp, dims)
    !-ARG
    integer(kind=c_int32_t), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int32_t_5

  subroutine fpDeallocate__integer_c_int32_t_5(fp)
    !-ARG
    integer(kind=c_int32_t), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int32_t_5

  function mxArrayHeader__integer_c_int32_t_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int32_t), intent(in) :: REPIDX_5(A,:)
    integer(kind=c_int32_t), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT32_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int32_t_5

  subroutine fpGetPr__integer_c_int16_t_1(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_1

  subroutine fpGetPi__integer_c_int16_t_1(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_1

  subroutine fpAllocate__integer_c_int16_t_1(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_1

  subroutine fpDeallocate__integer_c_int16_t_1(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_1

  function mxArrayHeader__integer_c_int16_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_1(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int16_t_1

  subroutine fpGetPr__real_c_double_6(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_6

  subroutine fpGetPi__real_c_double_6(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_6

  subroutine fpAllocate__real_c_double_6(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_6

  subroutine fpDeallocate__real_c_double_6(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_6

  function mxArrayHeader__real_c_double_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_6(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_6

  subroutine fpGetPr__real_c_float_3(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_3

  subroutine fpGetPi__real_c_float_3(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_3

  subroutine fpAllocate__real_c_float_3(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_3

  subroutine fpDeallocate__real_c_float_3(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_3

  function mxArrayHeader__real_c_float_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_3(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_float_3

  subroutine fpGetPr__real_c_float_1(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_1

  subroutine fpGetPi__real_c_float_1(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_1

  subroutine fpAllocate__real_c_float_1(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_1

  subroutine fpDeallocate__real_c_float_1(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_1

  function mxArrayHeader__real_c_float_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_1(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_float_1

  subroutine fpGetPr__real_c_float_0(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_0

  subroutine fpGetPi__real_c_float_0(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_0

  subroutine fpAllocate__real_c_float_0(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__real_c_float_0

  subroutine fpDeallocate__real_c_float_0(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_0

  function mxArrayHeader__real_c_float_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_0(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__real_c_float_0

  subroutine fpGetPr__integer_c_int64_t_1(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_1

  subroutine fpGetPi__integer_c_int64_t_1(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_1

  subroutine fpAllocate__integer_c_int64_t_1(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_1

  subroutine fpDeallocate__integer_c_int64_t_1(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_1

  function mxArrayHeader__integer_c_int64_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_1(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int64_t_1

  subroutine fpGetPr__real_c_float_2(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_2

  subroutine fpGetPi__real_c_float_2(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_2

  subroutine fpAllocate__real_c_float_2(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_2

  subroutine fpDeallocate__real_c_float_2(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_2

  function mxArrayHeader__real_c_float_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_2(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_float_2

  subroutine fpGetPr__integer_c_int16_t_3(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_3

  subroutine fpGetPi__integer_c_int16_t_3(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_3

  subroutine fpAllocate__integer_c_int16_t_3(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_3

  subroutine fpDeallocate__integer_c_int16_t_3(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_3

  function mxArrayHeader__integer_c_int16_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_3(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_3

  subroutine fpGetPr__real_c_double_4(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_4

  subroutine fpGetPi__real_c_double_4(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_4

  subroutine fpAllocate__real_c_double_4(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_4

  subroutine fpDeallocate__real_c_double_4(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_4

  function mxArrayHeader__real_c_double_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_4(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_4

  subroutine fpGetPr__integer_c_int64_t_6(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_6

  subroutine fpGetPi__integer_c_int64_t_6(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(6)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 6 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_6

  subroutine fpAllocate__integer_c_int64_t_6(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_6(fp,:)
    mwSize, intent(in) :: dims(6) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,6
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_6

  subroutine fpDeallocate__integer_c_int64_t_6(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_6(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_6(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_6

  function mxArrayHeader__integer_c_int64_t_6(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_6(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_6(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(6), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 6
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_6(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_6(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int64_t_6

  subroutine fpGetPr__real_c_double_5(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: prc
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_double_5

  subroutine fpGetPi__real_c_double_5(fp, mx)
!-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(5)
    type(c_ptr) :: pic
!-----
        if( mxIsDouble(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 5 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_double_5

  subroutine fpAllocate__real_c_double_5(fp, dims)
    !-ARG
    real(kind=c_double), pointer, intent(out) :: REPIDX_5(fp,:)
    mwSize, intent(in) :: dims(5) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,5
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_double_5

  subroutine fpDeallocate__real_c_double_5(fp)
    !-ARG
    real(kind=c_double), pointer :: REPIDX_5(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_5(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_double_5

  function mxArrayHeader__real_c_double_5(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_double), intent(in) :: REPIDX_5(A,:)
    real(kind=c_double), optional, intent(in) :: REPIDX_5(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(5), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxDOUBLE_CLASS
    mx = 0
        ndim = 5
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_5(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_5(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_double_5

  subroutine fpGetPr__real_c_float_4(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__real_c_float_4

  subroutine fpGetPi__real_c_float_4(fp, mx)
!-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( mxIsSingle(mx) == 1 .and. mxIsSparse(mx) == 0 .and. &
            mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__real_c_float_4

  subroutine fpAllocate__real_c_float_4(fp, dims)
    !-ARG
    real(kind=c_float), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 4

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__real_c_float_4

  subroutine fpDeallocate__real_c_float_4(fp)
    !-ARG
    real(kind=c_float), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__real_c_float_4

  function mxArrayHeader__real_c_float_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    real(kind=c_float), intent(in) :: REPIDX_4(A,:)
    real(kind=c_float), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxSINGLE_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__real_c_float_4

  subroutine fpGetPr__integer_c_int64_t_0(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_0

  subroutine fpGetPi__integer_c_int64_t_0(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_0

  subroutine fpAllocate__integer_c_int64_t_0(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int64_t_0

  subroutine fpDeallocate__integer_c_int64_t_0(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_0

  function mxArrayHeader__integer_c_int64_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_0(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int64_t_0

  subroutine fpGetPr__integer_c_int8_t_4(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_4

  subroutine fpGetPi__integer_c_int8_t_4(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_4

  subroutine fpAllocate__integer_c_int8_t_4(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_4

  subroutine fpDeallocate__integer_c_int8_t_4(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_4

  function mxArrayHeader__integer_c_int8_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_4(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_4

  subroutine fpGetPr__integer_c_int64_t_3(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_3

  subroutine fpGetPi__integer_c_int64_t_3(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_3

  subroutine fpAllocate__integer_c_int64_t_3(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_3

  subroutine fpDeallocate__integer_c_int64_t_3(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_3

  function mxArrayHeader__integer_c_int64_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_3(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int64_t_3

  subroutine fpGetPr__integer_c_int8_t_2(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_2

  subroutine fpGetPi__integer_c_int8_t_2(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_2

  subroutine fpAllocate__integer_c_int8_t_2(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_2

  subroutine fpDeallocate__integer_c_int8_t_2(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_2

  function mxArrayHeader__integer_c_int8_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_2(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_2

  subroutine fpGetPr__integer_c_int64_t_2(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_2

  subroutine fpGetPi__integer_c_int64_t_2(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_2

  subroutine fpAllocate__integer_c_int64_t_2(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_2

  subroutine fpDeallocate__integer_c_int64_t_2(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_2

  function mxArrayHeader__integer_c_int64_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_2(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int64_t_2

  subroutine fpGetPr__integer_c_int64_t_4(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int64_t_4

  subroutine fpGetPi__integer_c_int64_t_4(fp, mx)
!-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(4)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt64(mx) == 1 .or. mxIsUint64(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 4 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int64_t_4

  subroutine fpAllocate__integer_c_int64_t_4(fp, dims)
    !-ARG
    integer(kind=c_int64_t), pointer, intent(out) :: REPIDX_4(fp,:)
    mwSize, intent(in) :: dims(4) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 8

        n = 1
        do i=1,4
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int64_t_4

  subroutine fpDeallocate__integer_c_int64_t_4(fp)
    !-ARG
    integer(kind=c_int64_t), pointer :: REPIDX_4(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_4(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int64_t_4

  function mxArrayHeader__integer_c_int64_t_4(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int64_t), intent(in) :: REPIDX_4(A,:)
    integer(kind=c_int64_t), optional, intent(in) :: REPIDX_4(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(4), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT64_CLASS
    mx = 0
        ndim = 4
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_4(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_4(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int64_t_4

  subroutine fpGetPr__integer_c_int8_t_3(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_3

  subroutine fpGetPi__integer_c_int8_t_3(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(3)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        dims => fpGetDimensions(mx)
        if( size(dims) <= 3 .and. &
            mxGetNumberOfElements(mx) > 0 ) then
          dimz = 1
          dimz(1:size(dims)) = dims
          pi = mxGetData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, dimz)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_3

  subroutine fpAllocate__integer_c_int8_t_3(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_3(fp,:)
    mwSize, intent(in) :: dims(3) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,3
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_3

  subroutine fpDeallocate__integer_c_int8_t_3(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_3(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_3(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_3

  function mxArrayHeader__integer_c_int8_t_3(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_3(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_3(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(3), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 3
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_3(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_3(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int8_t_3

  subroutine fpGetPr__integer_c_int8_t_0(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_0

  subroutine fpGetPi__integer_c_int8_t_0(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(0)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfElements( mx ) == 1 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_0

  subroutine fpAllocate__integer_c_int8_t_0(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_0(fp,:)
    mwSize, intent(in) :: dims(0) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        mxmemory = mxMalloc(element)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp)
        endif
  end subroutine fpAllocate__integer_c_int8_t_0

  subroutine fpDeallocate__integer_c_int8_t_0(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_0(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then

      mxmemory = loc( REPIDX_0(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_0

  function mxArrayHeader__integer_c_int8_t_0(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_0(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_0(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(0), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( mx == 0 ) return
        dims2 = 1
        if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc(A)
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc(B)
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int8_t_0

  subroutine fpGetPr__integer_c_int16_t_2(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          dims => fpGetDimensions(mx)
          call c_f_pointer(prc, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int16_t_2

  subroutine fpGetPi__integer_c_int16_t_2(fp, mx)
!-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(2)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt16(mx) == 1 .or. mxIsUint16(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        if( mxGetNumberOfDimensions(mx) == 2 .and. &
            mxGetNumberOfElements(mx) > 0) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          dims => fpGetDimensions(mx)
          call c_f_pointer(pic, fp, dims)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int16_t_2

  subroutine fpAllocate__integer_c_int16_t_2(fp, dims)
    !-ARG
    integer(kind=c_int16_t), pointer, intent(out) :: REPIDX_2(fp,:)
    mwSize, intent(in) :: dims(2) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 2

        n = 1
        do i=1,2
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int16_t_2

  subroutine fpDeallocate__integer_c_int16_t_2(fp)
    !-ARG
    integer(kind=c_int16_t), pointer :: REPIDX_2(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_2(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int16_t_2

  function mxArrayHeader__integer_c_int16_t_2(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int16_t), intent(in) :: REPIDX_2(A,:)
    integer(kind=c_int16_t), optional, intent(in) :: REPIDX_2(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(2), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT16_CLASS
    mx = 0
        ndim = 2
        dims = 0
        if( present(B) ) then
          do i=1,ndim
            if( size(A,i) /= size(B,i) ) then
              mx = 0
              return
            endif
          enddo
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxCOMPLEX)
        else
          mx = mxCreateNumericArray(ndim, dims, mxCLASS, mxREAL)
        endif
        if( mx == 0 .or. size(A) == 0 ) return
        do i=1,ndim
            dims(i) = size(A,i)
        enddo
        if( mxSetDimensions(mx, dims, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( REPIDX_2(A,1) )
        call mxSetData(mx, address)
        if( present(B) ) then
          address = loc( REPIDX_2(B,1) )
          call mxSetImagData(mx, address )
        endif

  end function mxArrayHeader__integer_c_int16_t_2

  subroutine fpGetPr__integer_c_int8_t_1(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pr
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: prc
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pr = mxGetData(mx)
          prc = transfer(pr, prc)
          call c_f_pointer(prc, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPr__integer_c_int8_t_1

  subroutine fpGetPi__integer_c_int8_t_1(fp, mx)
!-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwPointer :: pi
    mwSize, pointer :: dims(:)
    mwSize :: N(1), dimz(1)
    type(c_ptr) :: pic
!-----
        if( ( mxIsInt8(mx) == 1 .or. mxIsUint8(mx) == 1 ) .and. &
              mxIsSparse(mx) == 0 .and. mxIsComplex(mx) == 1 ) then
        N(1) = mxGetNumberOfElements( mx )
        if( N(1) > 0 ) then
          pi = mxGetImagData(mx)
          pic = transfer(pi, pic)
          call c_f_pointer(pic, fp, N)
      else
        nullify( fp )
      endif
    else
      nullify( fp )
    endif
  end subroutine fpGetPi__integer_c_int8_t_1

  subroutine fpAllocate__integer_c_int8_t_1(fp, dims)
    !-ARG
    integer(kind=c_int8_t), pointer, intent(out) :: REPIDX_1(fp,:)
    mwSize, intent(in) :: dims(1) 
    !-LOC
    mwPointer :: mxmemory
    mwSize :: i, p, n, element
    type(c_ptr) :: prc
    character (len=100) :: errmsg
    !-----
    nullify(fp)
        element = 1

        n = 1
        do i=1,1
          if( dims(i) <= 0 ) return
          p = n * dims(i)
          if( (p / dims(i)) /= n ) return
          n = p
        enddo
        p = n * element
        if( (p / element) /= n ) return
        mxmemory = mxMalloc(p)
        if( mxmemory /= 0 ) then
          prc = transfer(mxmemory, prc)
          call c_f_pointer(prc, fp, dims)
        endif
  end subroutine fpAllocate__integer_c_int8_t_1

  subroutine fpDeallocate__integer_c_int8_t_1(fp)
    !-ARG
    integer(kind=c_int8_t), pointer :: REPIDX_1(fp,:)
    !-LOC
    mwPointer :: mxmemory
    !-----
    if( associated(fp) ) then
        if( size(fp) == 0 ) then 
          nullify(fp)
          return
        endif
      mxmemory = loc( REPIDX_1(fp,1) )
      call mxFree(mxmemory)
      nullify(fp)
    endif
  end subroutine fpDeallocate__integer_c_int8_t_1

  function mxArrayHeader__integer_c_int8_t_1(A, B, orient) result(mx)
    mwPointer :: mx
    !-ARG
    integer(kind=c_int8_t), intent(in) :: REPIDX_1(A,:)
    integer(kind=c_int8_t), optional, intent(in) :: REPIDX_1(B,:)
    character(len=*), optional, intent(in) :: orient
    !-LOC
    character(len=6) :: rowcol
    mwPointer :: address
    mwSize, parameter :: Zero = 0
    mwSize :: ndim, i, dims(1), dims2(2)
    integer(4) :: mxCLASS
    !-----
        mxCLASS = mxINT8_CLASS
    mx = 0
        
        ndim = 2
        dims2 = 0
        if( present(B) ) then
          if( size(A) == size(B) ) then
            mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxCOMPLEX)
          else
            return
          endif
        else
          mx = mxCreateNumericArray(ndim, dims2, mxCLASS, mxREAL)
        endif
        if( present(orient) ) then
          rowcol = uppercase(orient)
          if( rowcol == 'ROW' ) then
            dims2(1) = 1
            dims2(2) = size(A)
          elseif( rowcol == 'COLUMN' .or. rowcol == 'COL' ) then
            dims2(1) = size(A)
            dims2(2) = 1
          else
            call mxDestroyArray(mx)
            mx = 0
            return
          endif
        else
          dims2(1) = size(A)
          dims2(2) = 1
        endif
        if( mx == 0 .or. size(A) == 0 ) return
                if( mxSetDimensions(mx, dims2, ndim) /= 0 ) then
          call mxDestroyArray(mx)
          mx = 0
          return
        endif
        address = loc( A(1) )
        call mxSetData(mx, address)
        if( present(B)) then
          address = loc( B(1) )
          call mxSetImagData(mx, address)
        endif

  end function mxArrayHeader__integer_c_int8_t_1

!
!-----
! fpGetCells
!-----
!
  subroutine fpGetCells__5( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_5(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(5)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 5 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__5
  subroutine fpGetCells__2( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_2(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(2)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 2 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__2
  subroutine fpGetCells__3( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_3(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(3)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 3 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__3
  subroutine fpGetCells__6( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_6(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(6)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 6 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__6
  subroutine fpGetCells__7( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_7(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(7)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 7 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__7
  subroutine fpGetCells__1( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_1(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(1)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dimz(1) = N
        call c_f_pointer(ppc, fp, dimz)
  end subroutine fpGetCells__1
  subroutine fpGetCells__4( fp, mx )
!-ARG
    mwPointer, pointer, intent(out) :: REPIDX_4(fp,:)
    mwPointer, intent(in) :: mx
!-LOC
    mwSize, pointer :: dims(:)
    mwSize :: ndim, N
    mwSize :: dimz(4)
    mwPointer :: cells
    type(c_ptr) :: ppc
!-----
    nullify(fp)
    if( mxIsCell(mx) == 0 ) return
    N = mxGetNumberOfElements(mx)
    if( N <= 0 ) return
    cells = mxGetData( mx )
    ppc = transfer(cells, ppc)
        dims => fpGetDimensions(mx)
        ndim = size(dims)
        if( ndim <= 4 ) then
          dimz = 1
          dimz(1:ndim) = dims
          call c_f_pointer(ppc, fp, dimz)
        endif
  end subroutine fpGetCells__4
    
!
!-----
! Non-templated subroutines
!-----
!
  function fpGetDimensions( mx ) result(fp)
    implicit none
    mwSize, pointer :: fp(:)
!-ARG
    mwPointer, intent(in) :: mx
!-LOC
    mwSize :: ndim(1)
    mwPointer :: dims
    type(c_ptr) :: dimsc
!-----
    ndim(1) = mxGetNumberOfDimensions( mx )
    dims = mxGetDimensions( mx )
    dimsc = transfer(dims, dimsc)
    call c_f_pointer(dimsc, fp, ndim)
  end function fpGetDimensions

  function uppercase(string) result(upper)
    character(len=*), intent(in) :: string
    character(len=len(string)) :: upper
    integer :: j
    do j = 1,len(string)
        if(string(j:j) >= "a" .and. string(j:j) <= "z") then
            upper(j:j) = achar(iachar(string(j:j)) - 32)
        else
            upper(j:j) = string(j:j)
        end if
    enddo
  end function uppercase

end module MatlabAPImx


